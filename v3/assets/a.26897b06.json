{"title":"Customize Ability","categories":["advanced"],"order":65,"meta":{"keywords":null,"description":null},"content":"<p>CASL was built with extensibility in mind and this allows you to extend conditions with custom operators, provide custom field matchers and even use your own implementation to match conditions (e.g., using functions or <a href=\"https://json-schema.org/\" target=\"_blank\" rel=\"noopener nofollow\">json-schema</a>)! Let's see how</p>\n<h2 id=\"extend-conditions-with-custom-operators\"><a name=\"extend-conditions-with-custom-operators\" class=\"h-link\" href=\"#\"></a>Extend conditions with custom operators</h2>\n<p>Thanks to <a href=\"https://github.com/crcn/sift.js\" target=\"_blank\" rel=\"noopener nofollow\">sift.js</a>, it's possible to <app-link to=\"page\" params=\"{&quot;id&quot;:&quot;guide/conditions-in-depth&quot;}\">define conditions in CASL</app-link> using MongoDB query language. Usually this is enough but sometimes you may want to add non-standard operator or one of those that are not included in CASL by default (e.g., <a href=\"https://docs.mongodb.com/manual/reference/operator/query/nor/\" target=\"_blank\" rel=\"noopener nofollow\">$nor</a>) or you may want to restrict possible operators.</p>\n<p>Let's see an example how to add <code>$nor</code> operator. To do this, we will use <code>buildMongoQueryMatcher</code> helper function from <code>@casl/ability</code> package. It allows to add or override existing operators:</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">import</span> {\n  Ability,\n  AbilityBuilder,\n  Abilities,\n  MongoQuery,\n  buildMongoQueryMatcher,\n} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@casl/ability'</span>;\n<span class=\"hljs-keyword\">import</span> { $nor } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'sift'</span>;\n\n<span class=\"hljs-keyword\">interface</span> QueryExtensions {\n  $nor?: [MongoQuery, ...MongoQuery[]]\n};\n<span class=\"hljs-keyword\">type</span> CustomMongoQuery = MongoQuery | QueryExtensions;\n<span class=\"hljs-keyword\">const</span> conditionsMatcher = buildMongoQueryMatcher&lt;QueryExtensions&gt;({ $nor });\n<span class=\"hljs-keyword\">type</span> AppAbility = Ability&lt;Abilities, CustomMongoQuery&gt;;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">defineAbilityFor</span>(<span class=\"hljs-params\">user: <span class=\"hljs-built_in\">any</span></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> { can, build } = <span class=\"hljs-keyword\">new</span> AbilityBuilder&lt;AppAbility&gt;(Ability);\n\n  can(<span class=\"hljs-string\">'read'</span>, <span class=\"hljs-string\">'Article'</span>, {\n    $nor: [{ <span class=\"hljs-keyword\">private</span>: <span class=\"hljs-literal\">true</span> }, { authorId: user.id }]\n  });\n\n  <span class=\"hljs-keyword\">return</span> build({ conditionsMatcher });\n}\n</code></pre>\n<blockquote>\n<p>We use <code>user: any</code> for the purpose of ease, you should avoid this in real apps</p>\n</blockquote>\n<p>To restrict operators you shouldn't use <code>buildMongoQueryMatcher</code>. For example, let's allow to use only <code>$eq</code> and <code>$in</code> operators:</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">import</span> {\n  Ability,\n  AbilityBuilder,\n  Abilities,\n  MongoQueryOperators,\n  ConditionsMatcher,\n} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@casl/ability'</span>;\n<span class=\"hljs-keyword\">import</span> { $<span class=\"hljs-keyword\">in</span>, $eq, Query, createQueryTester <span class=\"hljs-keyword\">as</span> sift } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'sift'</span>;\n\n<span class=\"hljs-keyword\">type</span> RestrictedMongoQuery = Record&lt;PropertyKey, <span class=\"hljs-built_in\">number</span> | <span class=\"hljs-built_in\">string</span> | {\n  $eq?: MongoQueryOperators[<span class=\"hljs-string\">'$eq'</span>],\n  $<span class=\"hljs-keyword\">in</span>?: MongoQueryOperators[<span class=\"hljs-string\">'$in'</span>],\n}&gt;;\n<span class=\"hljs-keyword\">const</span> conditionsMatcher: ConditionsMatcher&lt;RestrictedMongoQuery&gt; = <span class=\"hljs-function\">(<span class=\"hljs-params\">conditions</span>) =&gt;</span> {\n  <span class=\"hljs-keyword\">return</span> sift(conditions <span class=\"hljs-keyword\">as</span> Query, { operations: { $<span class=\"hljs-keyword\">in</span>, $eq } });\n};\n<span class=\"hljs-keyword\">type</span> AppAbility = Ability&lt;Abilities, RestrictedMongoQuery&gt;;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">defineAbilityFor</span>(<span class=\"hljs-params\">user: <span class=\"hljs-built_in\">any</span></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> { can, build } = <span class=\"hljs-keyword\">new</span> AbilityBuilder&lt;AppAbility&gt;(Ability);\n\n  can(<span class=\"hljs-string\">'read'</span>, <span class=\"hljs-string\">'Article'</span>, { authorId: user.id } });\n  can(<span class=\"hljs-string\">'read'</span>, <span class=\"hljs-string\">'Article'</span>, { status: { $<span class=\"hljs-keyword\">in</span>: [<span class=\"hljs-string\">'draft'</span>, <span class=\"hljs-string\">'published'</span>] } });\n\n  <span class=\"hljs-keyword\">return</span> build({ conditionsMatcher });\n}\n</code></pre>\n<blockquote>\n<p>Read <a href=\"https://github.com/crcn/sift.js#custom-operations\" target=\"_blank\" rel=\"noopener nofollow\">sift docs</a> page to learn how to create custom operators.</p>\n</blockquote>\n<p>By restricting operators, you not only disallow other developers to use more complex conditions but also make your frontend bundle size smaller (thanks to bundlers with tree-shaking support).</p>\n<h2 id=\"custom-conditions-matcher-implementation\"><a name=\"custom-conditions-matcher-implementation\" class=\"h-link\" href=\"#\"></a>Custom conditions matcher implementation</h2>\n<p>If you want to implement custom conditions matcher, you should use <code>PureAbility</code> class instead of <code>Ability</code>. <code>PureAbility</code> is a parent class for <code>Ability</code>, the only difference between them is that <code>Ability</code> has restriction on <code>Conditions</code> generic parameter and has default values for <code>conditionsMatcher</code> and <code>fieldMatcher</code> options.</p>\n<blockquote>\n<p>The prefix &quot;Pure&quot; has nothing to do with functional programming. It just means this class has no predefined configuration.</p>\n</blockquote>\n<p>Conditions matcher is a factory function that accepts <code>rule.conditions</code> and returns a function that accepts an object and returns boolean. All these restrictions on conditions matcher is enforced by <code>ConditionsMatcher</code> generic type which you can import from <code>@casl/ability</code>.</p>\n<p>Let's implement the matcher that allows to use a function as conditions matcher:</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">import</span> {\n  PureAbility,\n  AbilityBuilder,\n  Abilities,\n  MatchConditions,\n  ConditionsMatcher\n} <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@casl/ability'</span>;\n\n<span class=\"hljs-keyword\">type</span> AppAbility = PureAbility&lt;Abilities, MatchConditions&gt;;\n<span class=\"hljs-keyword\">const</span> lambdaMatcher: ConditionsMatcher&lt;MatchConditions&gt; = <span class=\"hljs-function\"><span class=\"hljs-params\">matchConditions</span> =&gt;</span> matchConditions;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">defineAbilityFor</span>(<span class=\"hljs-params\">user: <span class=\"hljs-built_in\">any</span></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> { can, build } = <span class=\"hljs-keyword\">new</span> AbilityBuilder&lt;AppAbility&gt;();\n\n  can(<span class=\"hljs-string\">'read'</span>, <span class=\"hljs-string\">'Article'</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">{ authorId }</span>) =&gt;</span> authorId === user.id);\n  can(<span class=\"hljs-string\">'read'</span>, <span class=\"hljs-string\">'Article'</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">{ status }</span>) =&gt;</span> [<span class=\"hljs-string\">'draft'</span>, <span class=\"hljs-string\">'published'</span>].includes(status));\n\n  <span class=\"hljs-keyword\">return</span> build({ conditionsMatcher: lambdaMatcher });\n}\n</code></pre>\n<blockquote>\n<p>Conditions matchers can be only synchronous!</p>\n</blockquote>\n<p>We don't recommend to use functions for matching logic if you need to serialize rules or convert them to a database query. The default matcher should cover majority of cases.</p>\n<h2 id=\"custom-field-matcher\"><a name=\"custom-field-matcher\" class=\"h-link\" href=\"#\"></a>Custom field matcher</h2>\n<p>Field matcher is responsible for matching fields passed as 3rd argument to <code>can</code> method of <code>Ability</code> instance. It is a factory function that returns a function which accepts field and returns boolean. This logic is enforced by <code>FieldMatcher</code> type from <code>@casl/ability</code>.</p>\n<blockquote>\n<p>We cannot imagine a reasonable case to override field matching logic, <app-link to=\"page\" params=\"{&quot;id&quot;:&quot;guide/restricting-fields&quot;}\">default implementation</app-link> should be more than enough.</p>\n</blockquote>\n<p>You can use this to reduce your bundle size or enforce simpler logic. For example, let's implement simple field matcher that doesn't support field patterns:</p>\n<pre><code class=\"hljs language-ts\"><span class=\"hljs-keyword\">import</span> { Ability, AbilityBuilder, FieldMatcher } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">'@casl/ability'</span>;\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> fieldMatcher: FieldMatcher = <span class=\"hljs-function\"><span class=\"hljs-params\">fields</span> =&gt;</span> field =&gt; fields.includes(field);\n\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">defineAbilityFor</span>(<span class=\"hljs-params\">user: <span class=\"hljs-built_in\">any</span></span>) </span>{\n  <span class=\"hljs-keyword\">const</span> { can, build } = <span class=\"hljs-keyword\">new</span> AbilityBuilder(Ability);\n\n  can(<span class=\"hljs-string\">'read'</span>, <span class=\"hljs-string\">'Article'</span>, [<span class=\"hljs-string\">'title'</span>, <span class=\"hljs-string\">'content'</span>]);\n\n  <span class=\"hljs-keyword\">return</span> build({ fieldMatcher });\n}\n</code></pre>","headings":[{"id":"extend-conditions-with-custom-operators","title":"Extend conditions with custom operators"},{"id":"custom-conditions-matcher-implementation","title":"Custom conditions matcher implementation"},{"id":"custom-field-matcher","title":"Custom field matcher"}],"id":"advanced/customize-ability"}